#include "aimux/config/toon_parser.hpp"
#include <fstream>
#include <sstream>
#include <regex>
#include <algorithm>

namespace aimux {
namespace config {

/**
 * @brief Parse TOON format configuration file
 * TOON format: Tabular Object-Oriented Notation
 * Similar to TOML but optimized for AI provider configurations
 */

ToonParser::ToonParser() = default;

ToonParseResult ToonParser::parse_file(const std::string& filename) {
    ToonParseResult result;
    
    std::ifstream file(filename);
    if (!file.is_open()) {
        result.success = false;
        result.error = "Cannot open file: " + filename;
        return result;
    }
    
    std::string content((std::istreambuf_iterator<char>(file)),
                       std::istreambuf_iterator<char>());
    
    return parse_string(content);
}

ToonParseResult ToonParser::parse_string(const std::string& content) {
    ToonParseResult result;
    
    try {
        result.config = parse_toon_to_json(content);
        result.success = true;
    } catch (const std::exception& e) {
        result.success = false;
        result.error = "Parse error: " + std::string(e.what());
    }
    
    return result;
}

std::string ToonParser::json_to_toon(const nlohmann::json& json, int indent) {
    std::ostringstream toon;
    
    // Header
    toon << "# TOON Configuration File\n";
    toon << "# Generated by Aimux2 v2.0.0\n\n";
    
    // Convert JSON to TOON format
    json_to_toon_recursive(json, toon, indent, "");
    
    return toon.str();
}

nlohmann::json ToonParser::parse_toon_to_json(const std::string& content) {
    nlohmann::json json;
    std::istringstream stream(content);
    std::string line;
    std::string current_section;
    
    while (std::getline(stream, line)) {
        // Skip comments and empty lines
        line = std::regex_replace(line, std::regex("^\\s*#.*"), "");
        line = std::regex_replace(line, std::regex("^\\s*$"), "");
        if (line.empty()) continue;
        
        // Section headers [section]
        std::smatch section_match;
        if (std::regex_match(line, section_match, std::regex("^\\[([^\\]]+)\\]\\s*$"))) {
            current_section = section_match[1].str();
            json[current_section] = nlohmann::json::object();
            continue;
        }
        
        // Key-value pairs
        std::smatch kv_match;
        if (std::regex_match(line, kv_match, std::regex("^([^=]+)=(.*)$"))) {
            std::string key = std::regex_replace(kv_match[1].str(), std::regex("^\\s+|\\s+$"), "");
            std::string value = std::regex_replace(kv_match[2].str(), std::regex("^\\s+|\\s+$"), "");
            
            // Parse value type
            nlohmann::json parsed_value = parse_toon_value(value);
            
            if (!current_section.empty()) {
                json[current_section][key] = parsed_value;
            } else {
                json[key] = parsed_value;
            }
        }
    }
    
    return json;
}

nlohmann::json ToonParser::parse_toon_value(const std::string& value) {
    // Boolean values
    if (value == "true") return true;
    if (value == "false") return false;
    
    // Null value
    if (value == "null" || value == "none") return nullptr;
    
    // Numeric values
    std::regex number_regex("^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$");
    if (std::regex_match(value, number_regex)) {
        if (value.find('.') != std::string::npos || value.find('e') != std::string::npos) {
            return std::stod(value);
        } else {
            return std::stoll(value);
        }
    }
    
    // String values (remove quotes if present)
    std::string result = value;
    if ((result.front() == '"' && result.back() == '"') ||
        (result.front() == '\'' && result.back() == '\'')) {
        result = result.substr(1, result.length() - 2);
    }
    
    // Array values
    if (result.front() == '[' && result.back() == ']') {
        std::string array_content = result.substr(1, result.length() - 2);
        std::vector<std::string> items;
        std::stringstream ss(array_content);
        std::string item;
        
        while (std::getline(ss, item, ',')) {
            item = std::regex_replace(item, std::regex("^\\s+|\\s+$"), "");
            if (!item.empty()) {
                items.push_back(item);
            }
        }
        
        nlohmann::json array = nlohmann::json::array();
        for (const auto& array_item : items) {
            array.push_back(parse_toon_value(array_item));
        }
        return array;
    }
    
    return result;
}

void ToonParser::json_to_toon_recursive(const nlohmann::json& json, 
                                       std::ostringstream& toon, 
                                       int indent, 
                                       const std::string& prefix) {
    for (auto it = json.begin(); it != json.end(); ++it) {
        std::string key = it.key();
        auto value = it.value();
        
        if (value.is_object()) {
            // Object section
            toon << "[" << key << "]\n";
            json_to_toon_recursive(value, toon, indent + 2, key);
            toon << "\n";
        } else if (value.is_array()) {
            // Array
            toon << std::string(indent, ' ') << key << " = [";
            bool first = true;
            for (const auto& item : value) {
                if (!first) toon << ", ";
                toon << toon_value_to_string(item);
                first = false;
            }
            toon << "]\n";
        } else {
            // Primitive value
            toon << std::string(indent, ' ') << key << " = " << toon_value_to_string(value) << "\n";
        }
    }
}

std::string ToonParser::toon_value_to_string(const nlohmann::json& value) {
    if (value.is_null()) return "null";
    if (value.is_boolean()) return value.get<bool>() ? "true" : "false";
    if (value.is_number()) return value.dump();
    if (value.is_string()) return "\"" + value.get<std::string>() + "\"";
    if (value.is_array()) {
        std::string result = "[";
        bool first = true;
        for (const auto& item : value) {
            if (!first) result += ", ";
            result += toon_value_to_string(item);
            first = false;
        }
        result += "]";
        return result;
    }
    return value.dump();
}

} // namespace config
} // namespace aimux
