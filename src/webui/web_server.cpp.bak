#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fstream>
#include <sstream>
#include <iostream>
#include <algorithm>

#include "aimux/webui/web_server.hpp"
#include "aimux/providers/provider_impl.hpp"
#include "aimux/core/bridge.hpp"
#include "config/production_config.h"

namespace aimux {
namespace webui {

WebServer::WebServer(int port) : port_(port), bind_address_("127.0.0.1"), resolved_bind_address_("127.0.0.1") {
    metrics_.start_time = std::chrono::steady_clock::now();

    // Initialize providers with default configurations
    initialize_providers();
}

WebServer::WebServer(const aimux::config::WebUIConfig& config)
    : port_(config.port), bind_address_(config.bind_address) {

    metrics_.start_time = std::chrono::steady_clock::now();

    // Resolve the bind address using configuration manager
    auto& config_manager = aimux::config::ProductionConfigManager::getInstance();
    resolved_bind_address_ = config_manager.resolveBindAddress(config);

    std::cout << "WebUI configured to bind to: " << resolved_bind_address_ << ":" << port_ << std::endl;
    if (config.bind_address != resolved_bind_address_) {
        std::cout << "  (requested: " << config.bind_address << ", resolved: " << resolved_bind_address_ << ")" << std::endl;
    }

    // Initialize providers with default configurations
    initialize_providers();
}

void WebServer::initialize_providers() {
    nlohmann::json default_config = {
        {"api_key", "test_key"},
        {"endpoint", "https://api.example.com"},
        {"timeout", 30000},
        {"max_retries", 3}
    };

    // Create synthetic provider for testing
    try {
        auto synthetic = providers::ProviderFactory::create_provider("synthetic", default_config);
        if (synthetic) {
            providers_["synthetic"] = std::move(synthetic);
        }
    } catch (const std::exception& e) {
        std::cerr << "Failed to create synthetic provider: " << e.what() << std::endl;
    }

    // Note: In production, you would load actual API keys from secure storage
}

WebServer::~WebServer() {
    stop();
}

void WebServer::start() {
    if (running_.load()) {
        return; // Already running
    }
    
    running_.store(true);
    server_thread_ = std::thread(&WebServer::server_loop, this);
    
    std::cout << "Web server starting on " << resolved_bind_address_ << ":" << port_ << std::endl;
}

void WebServer::stop() {
    if (!running_.load()) {
        return; // Not running
    }
    
    running_.store(false);
    
    // Close server socket
    if (server_socket_ != -1) {
        close(server_socket_);
        server_socket_ = -1;
    }
    
    // Wait for server thread to finish
    if (server_thread_.joinable()) {
        server_thread_.join();
    }
    
    std::cout << "Web server stopped" << std::endl;
}

void WebServer::server_loop() {
    // Create server socket
    server_socket_ = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket_ == -1) {
        std::cerr << "Failed to create socket" << std::endl;
        return;
    }
    
    // Set socket options
    int opt = 1;
    if (setsockopt(server_socket_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        std::cerr << "Failed to set socket options" << std::endl;
        close(server_socket_);
        return;
    }
    
    // Bind socket
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port_);

    // Resolve bind address
    if (resolved_bind_address_ == "0.0.0.0") {
        server_addr.sin_addr.s_addr = INADDR_ANY;
    } else {
        if (inet_pton(AF_INET, resolved_bind_address_.c_str(), &server_addr.sin_addr) <= 0) {
            std::cerr << "Invalid bind address: " << resolved_bind_address_ << std::endl;
            close(server_socket_);
            return;
        }
    }
    
    if (bind(server_socket_, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        std::cerr << "Failed to bind to port " << port_ << std::endl;
        close(server_socket_);
        return;
    }
    
    // Listen for connections
    if (listen(server_socket_, 10) == -1) {
        std::cerr << "Failed to listen on socket" << std::endl;
        close(server_socket_);
        return;
    }
    
    std::cout << "Web server listening on " << resolved_bind_address_ << ":" << port_ << std::endl;
    
    // Accept connections
    while (running_.load()) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        
        int client_socket = accept(server_socket_, (struct sockaddr*)&client_addr, &client_len);
        if (client_socket == -1) {
            if (running_.load()) {
                std::cerr << "Failed to accept connection" << std::endl;
            }
            continue;
        }
        
        // Handle request
        std::string raw_request = read_request(client_socket);
        auto [method, path, body, headers] = parse_http_request(raw_request);
        HttpResponse response = handle_request(method, path, body);
        
        send_response(client_socket, response);
        close(client_socket);
        
        // Update metrics
        {
            std::lock_guard<std::mutex> lock(metrics_mutex_);
            metrics_.total_requests++;
            if (response.status_code == 200) {
                metrics_.successful_requests++;
            } else {
                metrics_.failed_requests++;
            }
        }
    }
}

std::string WebServer::read_request(int client_socket) {
    char buffer[4096];
    std::string request;
    
    ssize_t bytes_read = recv(client_socket, buffer, sizeof(buffer) - 1, 0);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        request = buffer;
    }
    
    return request;
}

std::tuple<std::string, std::string, std::string, std::map<std::string, std::string>>
WebServer::parse_http_request(const std::string& raw_request) {
    std::istringstream iss(raw_request);
    std::string method, path, version;
    iss >> method >> path >> version;
    
    // Parse headers
    std::map<std::string, std::string> headers;
    std::string line;
    while (std::getline(iss, line) && line != "\r" && line != "") {
        size_t colon_pos = line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = line.substr(0, colon_pos);
            std::string value = line.substr(colon_pos + 1);
            
            // Trim whitespace
            key.erase(0, key.find_first_not_of(" \t\r\n"));
            key.erase(key.find_last_not_of(" \t\r\n") + 1);
            value.erase(0, value.find_first_not_of(" \t\r\n"));
            value.erase(value.find_last_not_of(" \t\r\n") + 1);
            
            headers[key] = value;
        }
    }
    
    // Parse body
    std::string body;
    size_t content_length = 0;
    auto it = headers.find("Content-Length");
    if (it != headers.end()) {
        content_length = std::stoul(it->second);
        
        // Find start of body (after empty line)
        size_t body_start = raw_request.find("\r\n\r\n");
        if (body_start != std::string::npos) {
            body_start += 4;
            if (body_start + content_length <= raw_request.length()) {
                body = raw_request.substr(body_start, content_length);
            }
        }
    }
    
    return {method, path, body, headers};
}

HttpResponse WebServer::handle_request(const std::string& method, const std::string& path, const std::string& body) {
    // Handle OPTIONS for CORS
    if (method == "OPTIONS") {
        return HttpResponse(200, "application/json", "");
    }

    // Route handling with method support
    if (path == "/" || path == "") {
        return handle_root();
    } else if (path == "/metrics") {
        return handle_metrics();
    } else if (path == "/health") {
        return handle_health();
    } else if (path == "/providers") {
        if (method == "GET") {
            return handle_providers();
        } else if (method == "POST") {
            return handle_create_provider(body);
        }
    } else if (path.find("/providers/") == 0) {
        std::string provider_name = path.substr(11); // Remove "/providers/"
        if (method == "GET") {
            return handle_get_provider(provider_name);
        } else if (method == "PUT") {
            return handle_update_provider(provider_name, body);
        } else if (method == "DELETE") {
            return handle_delete_provider(provider_name);
        }
    } else if (path == "/status") {
        return handle_status();
    } else if (path == "/config") {
        if (method == "GET") {
            return handle_get_config();
        } else if (method == "POST") {
            return handle_update_config(body);
        }
    } else if (path == "/test" && method == "POST") {
        return handle_test_provider(body);
    } else if (path == "/api-endpoints") {
        return handle_api_info();
    } else {
        return HttpResponse(404, "application/json", R"({"error": "Not Found", "message": "The requested endpoint was not found"})");
    }

    return HttpResponse(405, "application/json", R"({"error": "Method Not Allowed"})");
}

HttpResponse WebServer::handle_root() {
    // Get network information
    auto network_info = get_network_info();

    std::ostringstream html;
    html << R"(
<!DOCTYPE html>
<html>
<head>
    <title>Aimux Provider Manager</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; }
        .header { background: #2563eb; color: white; padding: 2rem; text-align: center; margin: -40px -40px 20px -40px; }
        .header h1 { margin: 0; font-size: 2.5rem; }
        .card { background: white; padding: 25px; margin: 20px 0; border-radius: 12px; box-shadow: 0 2px 15px rgba(0,0,0,0.1); }
        .card h2 { color: #2563eb; margin-bottom: 20px; }
        .status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .status-item { background: #f8fafc; padding: 15px; border-radius: 8px; text-align: center; }
        .status-label { font-size: 0.875rem; color: #64748b; margin-bottom: 5px; text-transform: uppercase; }
        .status-value { font-size: 1.5rem; font-weight: 600; color: #1e293b; }
        .status-value.ip { font-size: 1rem; font-family: monospace; }
        .network-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .network-section { background: #f8fafc; padding: 15px; border-radius: 8px; }
        .network-section h3 { color: #1e293b; margin-bottom: 10px; font-size: 1.1rem; }
        .ip-list { list-style: none; padding: 0; margin: 5px 0; }
        .ip-list li { font-family: monospace; background: white; padding: 5px 8px; margin: 2px 0; border-radius: 4px; font-size: 0.875rem; }
        .ip-list li.valid { color: #16a34a; }
        .ip-list li.invalid { color: #64748b; }
        .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 6px; cursor: pointer; text-decoration: none; display: inline-block; }
        .btn-primary { background: #2563eb; color: white; }
        .btn-success { background: #16a34a; color: white; }
        .btn-secondary { background: #64748b; color: white; }
        .endpoint-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
        .endpoint-item { background: #f8fafc; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.875rem; }
        .endpoint-method { font-weight: 600; color: #2563eb; }
        .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 5px; }
        .status-indicator.online { background: #16a34a; }
        .status-indicator.offline { background: #dc2626; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Aimux Provider Manager</h1>
        <p>Multi-AI Provider Router Dashboard v2.0</p>
    </div>

    <div class="container">
        <div class="card">
            <h2>Network Configuration</h2>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">Bind Address</div>
                    <div class="status-value">)" << network_info.resolved_bind_address << R"(</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Port</div>
                    <div class="status-value">)" << network_info.port << R"(</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Web Server</div>
                    <div class="status-value">
                        <span class="status-indicator online"></span>Running
                    </div>
                </div>
                <div class="status-item">
                    <div class="status-label">ZeroTier</div>
                    <div class="status-value">
                        <span class="status-indicator )" << (network_info.zerotier_available ? "online" : "offline") << R"(</span>
                        )" << (network_info.zerotier_available ? "Available" : "Not Detected") << R"(
                    </div>
                </div>
            </div>
            <div class="network-grid">
                <div class="network-section">
                    <h3>Network Interfaces</h3>
                    <ul class="ip-list">
                        <li class="valid">üåê <strong>Access URL:</strong> http://" << network_info.resolved_bind_address << ":" << network_info.port << "</li>
                        <li class=\"valid\">üíª <strong>Resolved IP:</strong> " << network_info.resolved_bind_address << "</li>
                        <li class=\"valid\">‚öôÔ∏è <strong>Configured:</strong> " << network_info.bind_address << "</li>
                        " << (network_info.zerotier_available ? "<li class=\"valid\">üåç <strong>ZeroTier IP:</strong> " + network_info.zerotier_ip + "</li>" : "") << R"(
                    </ul>
                </div>
                <div class="network-section">
                    <h3>Available IP Addresses</h3>
                    <ul class="ip-list">)";

    if (network_info.available_ips.empty()) {
        html << "<li class=\"invalid\">No external IP addresses detected</li>";
    } else {
        for (const auto& ip : network_info.available_ips) {
            html << "<li class=\"valid\">üîó " << ip << "</li>";
        }
    }

    html << R"(</ul>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>System Status</h2>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">API</div>
                    <div class="status-value">Operational</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Version</div>
                    <div class="status-value">v2.0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Uptime</div>
                    <div class="status-value" id="uptime">Calculating...</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Requests</div>
                    <div class="status-value" id="requests">0</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Quick Actions</h2>
            <div style="text-align: center; padding: 20px 0;">
                <a href="/providers" class="btn btn-primary" target="_blank">View Provider Data</a>
                <a href="/health" class="btn btn-success" target="_blank">Health Check</a>
                <a href="/api-endpoints" class="btn btn-secondary" target="_blank">API Info</a>
            </div>
        </div>

        <div class="card">
            <h2>REST API Endpoints</h2>
            <div class="endpoint-list">
                <div class="endpoint-item">
                    <div><span class="endpoint-method">GET</span> /providers</div>
                    <div>List all providers</div>
                </div>
                <div class="endpoint-item">
                    <div><span class="endpoint-method">GET</span> /health</div>
                    <div>System health check</div>
                </div>
                <div class="endpoint-item">
                    <div><span class="endpoint-method">GET</span> /metrics</div>
                    <div>System metrics</div>
                </div>
                <div class="endpoint-item">
                    <div><span class="endpoint-method">POST</span> /test</div>
                    <div>Test provider</div>
                </div>
                <div class="endpoint-item">
                    <div><span class="endpoint-method">GET</span> /api-endpoints</div>
                    <div>API information</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>About</h2>
            <p><strong>Aimux v2.0</strong> is a high-performance multi-provider AI service router built in C++23.</p>
            <ul>
                <li>Multi-provider support (Cerebras, Z.AI, MiniMax, Synthetic)</li>
                <li>Thread-safe provider management</li>
                <li>Comprehensive REST API</li>
                <li>~10x faster than TypeScript implementation</li>
                <li>Enhanced network configuration with ZeroTier support</li>
                <li>System service management capabilities</li>
            </ul>
        </div>
    </div>

    <script>
        // Update metrics dynamically
        function updateMetrics() {
            fetch('/metrics')
                .then(response => response.json())
                .then(data => {
                    // Update uptime
                    if (data.uptime_seconds) {
                        const uptimeHours = Math.floor(data.uptime_seconds / 3600);
                        const uptimeMins = Math.floor((data.uptime_seconds % 3600) / 60);
                        document.getElementById('uptime').textContent =
                            uptimeHours > 0 ? `${uptimeHours}h ${uptimeMins}m` : `${uptimeMins}m`;
                    }

                    // Update request count
                    if (data.total_requests !== undefined) {
                        document.getElementById('requests').textContent = data.total_requests;
                    }
                })
                .catch(error => {
                    console.log('Error fetching metrics:', error);
                });
        }

        // Update metrics every 5 seconds
        updateMetrics(); // Initial update
        setInterval(updateMetrics, 5000);

        // Auto-refresh network info every 30 seconds
        setTimeout(() => {
            window.location.reload();
        }, 30000);
    </script>
</body>
</html>
)";

    return HttpResponse(200, "text/html", html.str());
}

HttpResponse WebServer::handle_metrics() {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    nlohmann::json metrics = metrics_.to_json();
    return HttpResponse(200, "application/json", metrics.dump(4));
}

HttpResponse WebServer::handle_health() {
    return HttpResponse(200, "application/json", R"({"status": "healthy", "service": "aimux-webui"})");
}

HttpResponse WebServer::handle_providers() {
    nlohmann::json response;
    response["providers"] = nlohmann::json::array();

    std::lock_guard<std::mutex> lock(providers_mutex_);

    int total = 0;
    int healthy = 0;

    for (const auto& [name, provider] : providers_) {
        nlohmann::json provider_info;
        provider_info["name"] = name;
        provider_info["type"] = get_provider_type(name);
        provider_info["status"] = provider->is_healthy() ? "healthy" : "unhealthy";
        provider_info["rate_limit"] = provider->get_rate_limit_status();

        response["providers"].push_back(provider_info);
        total++;
        if (provider->is_healthy()) {
            healthy++;
        }
    }

    // Also add supported but not configured providers
    auto supported = providers::ProviderFactory::get_supported_providers();
    for (const auto& supported_name : supported) {
        if (providers_.find(supported_name) == providers_.end()) {
            nlohmann::json provider_info;
            provider_info["name"] = supported_name;
            provider_info["type"] = get_provider_type(supported_name);
            provider_info["status"] = "not_configured";
            provider_info["rate_limit"] = nlohmann::json{};

            response["providers"].push_back(provider_info);
        }
    }

    response["total"] = total;
    response["healthy"] = healthy;
    response["supported_types"] = supported;

    return HttpResponse(200, "application/json", response.dump(4));
}

HttpResponse WebServer::handle_status() {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    nlohmann::json status = metrics_.to_json();
    status["system"] = nlohmann::json{
        {"webui", true},
        {"providers", true},
        {"version", "v2.0"}
    };
    return HttpResponse(200, "application/json", status.dump(4));
}

void WebServer::send_response(int client_socket, const HttpResponse& response) {
    std::ostringstream response_stream;
    response_stream << "HTTP/1.1 " << response.status_code << " OK\r\n";
    response_stream << "Content-Type: " << response.content_type << "\r\n";
    response_stream << "Content-Length: " << response.body.length() << "\r\n";
    response_stream << "Access-Control-Allow-Origin: *\r\n";
    response_stream << "Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS\r\n";
    response_stream << "Access-Control-Allow-Headers: Content-Type, Authorization\r\n";
    response_stream << "\r\n";
    response_stream << response.body;
    
    std::string response_str = response_stream.str();
    send(client_socket, response_str.c_str(), response_str.length(), 0);
}

void WebServer::update_provider_metrics(const std::string& provider_name, double response_time_ms, bool success) {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    metrics_.provider_response_times[provider_name] = response_time_ms;
    metrics_.provider_health[provider_name] = success;
}

WebMetrics WebServer::get_metrics() const {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    return metrics_;
}

// Helper method to get provider type
std::string WebServer::get_provider_type(const std::string& provider_name) {
    if (provider_name == "synthetic") return "test";
    if (provider_name == "cerebras") return "llm";
    if (provider_name == "zai") return "llm";
    if (provider_name == "minimax") return "llm";
    return "unknown";
}

// New REST API endpoints

HttpResponse WebServer::handle_get_provider(const std::string& provider_name) {
    std::lock_guard<std::mutex> lock(providers_mutex_);

    auto it = providers_.find(provider_name);
    if (it == providers_.end()) {
        return HttpResponse(404, "application/json",
            nlohmann::json{{"error", "Provider not found"}, {"provider", provider_name}}.dump());
    }

    nlohmann::json provider_info;
    provider_info["name"] = provider_name;
    provider_info["type"] = get_provider_type(provider_name);
    provider_info["status"] = it->second->is_healthy() ? "healthy" : "unhealthy";
    provider_info["rate_limit"] = it->second->get_rate_limit_status();
    provider_info["metrics"] = nlohmann::json{
        {"response_time_ms", metrics_.provider_response_times[provider_name]},
        {"health_status", metrics_.provider_health[provider_name]}
    };

    return HttpResponse(200, "application/json", provider_info.dump(4));
}

HttpResponse WebServer::handle_create_provider(const std::string& body) {
    try {
        nlohmann::json request_json = nlohmann::json::parse(body);

        if (!request_json.contains("name") || !request_json.contains("config")) {
            return HttpResponse(400, "application/json",
                R"({"error": "Bad Request", "message": "Missing 'name' or 'config' field"})");
        }

        std::string provider_name = request_json["name"];
        nlohmann::json config = request_json["config"];

        // Validate configuration
        if (!providers::ProviderFactory::validate_config(provider_name, config)) {
            return HttpResponse(400, "application/json",
                nlohmann::json{{"error", "Invalid configuration"}, {"provider", provider_name}}.dump());
        }

        std::lock_guard<std::mutex> lock(providers_mutex_);

        // Check if provider already exists
        if (providers_.find(provider_name) != providers_.end()) {
            return HttpResponse(409, "application/json",
                nlohmann::json{{"error", "Provider already exists"}, {"provider", provider_name}}.dump());
        }

        // Create provider
        auto provider = providers::ProviderFactory::create_provider(provider_name, config);
        if (!provider) {
            return HttpResponse(500, "application/json",
                nlohmann::json{{"error", "Failed to create provider"}, {"provider", provider_name}}.dump());
        }

        providers_[provider_name] = std::move(provider);

        return HttpResponse(201, "application/json",
            nlohmann::json{{"message", "Provider created successfully"}, {"provider", provider_name}}.dump());

    } catch (const nlohmann::json::parse_error& e) {
        return HttpResponse(400, "application/json",
            nlohmann::json{{"error", "Invalid JSON"}, {"message", e.what()}}.dump());
    } catch (const std::exception& e) {
        return HttpResponse(500, "application/json",
            nlohmann::json{{"error", "Internal server error"}, {"message", e.what()}}.dump());
    }
}

HttpResponse WebServer::handle_update_provider(const std::string& provider_name, const std::string& body) {
    std::lock_guard<std::mutex> lock(providers_mutex_);

    auto it = providers_.find(provider_name);
    if (it == providers_.end()) {
        return HttpResponse(404, "application/json",
            nlohmann::json{{"error", "Provider not found"}, {"provider", provider_name}}.dump());
    }

    try {
        nlohmann::json request_json = nlohmann::json::parse(body);
        nlohmann::json new_config = request_json["config"];

        // Validate configuration
        if (!providers::ProviderFactory::validate_config(provider_name, new_config)) {
            return HttpResponse(400, "application/json",
                nlohmann::json{{"error", "Invalid configuration"}, {"provider", provider_name}}.dump());
        }

        // Create new provider with updated config
        auto new_provider = providers::ProviderFactory::create_provider(provider_name, new_config);
        if (!new_provider) {
            return HttpResponse(500, "application/json",
                nlohmann::json{{"error", "Failed to update provider"}, {"provider", provider_name}}.dump());
        }

        providers_[provider_name] = std::move(new_provider);

        return HttpResponse(200, "application/json",
            nlohmann::json{{"message", "Provider updated successfully"}, {"provider", provider_name}}.dump());

    } catch (const nlohmann::json::parse_error& e) {
        return HttpResponse(400, "application/json",
            nlohmann::json{{"error", "Invalid JSON"}, {"message", e.what()}}.dump());
    } catch (const std::exception& e) {
        return HttpResponse(500, "application/json",
            nlohmann::json{{"error", "Internal server error"}, {"message", e.what()}}.dump());
    }
}

HttpResponse WebServer::handle_delete_provider(const std::string& provider_name) {
    std::lock_guard<std::mutex> lock(providers_mutex_);

    auto it = providers_.find(provider_name);
    if (it == providers_.end()) {
        return HttpResponse(404, "application/json",
            nlohmann::json{{"error", "Provider not found"}, {"provider", provider_name}}.dump());
    }

    providers_.erase(it);

    return HttpResponse(200, "application/json",
        nlohmann::json{{"message", "Provider deleted successfully"}, {"provider", provider_name}}.dump());
}

HttpResponse WebServer::handle_get_config() {
    nlohmann::json config = providers::ConfigParser::generate_default_config();
    return HttpResponse(200, "application/json", config.dump(4));
}

HttpResponse WebServer::handle_update_config(const std::string& body) {
    try {
        nlohmann::json config_json = nlohmann::json::parse(body);

        if (!providers::ConfigParser::validate_config_structure(config_json)) {
            return HttpResponse(400, "application/json",
                R"({"error": "Invalid configuration structure"})");
        }

        // In a real implementation, you would save this to a file
        // For now, just return success
        return HttpResponse(200, "application/json",
            R"({"message": "Configuration updated successfully"})");

    } catch (const nlohmann::json::parse_error& e) {
        return HttpResponse(400, "application/json",
            nlohmann::json{{"error", "Invalid JSON"}, {"message", e.what()}}.dump());
    }
}

HttpResponse WebServer::handle_test_provider(const std::string& body) {
    try {
        nlohmann::json request_json = nlohmann::json::parse(body);

        if (!request_json.contains("provider")) {
            return HttpResponse(400, "application/json",
                R"({"error": "Missing 'provider' field"})");
        }

        std::string provider_name = request_json["provider"];
        std::string test_message = request_json.value("message", "Hello, this is a test message.");

        std::lock_guard<std::mutex> lock(providers_mutex_);

        auto it = providers_.find(provider_name);
        if (it == providers_.end()) {
            return HttpResponse(404, "application/json",
                nlohmann::json{{"error", "Provider not found"}, {"provider", provider_name}}.dump());
        }

        // Create a test request
        aimux::core::Request test_request;
        test_request.model = "test-model";
        test_request.method = "chat";
        test_request.data = nlohmann::json{
            {"messages", nlohmann::json::array({{
                {"role", "user"},
                {"content", test_message}
            }})}
        };

        // Measure response time
        auto start_time = std::chrono::steady_clock::now();
        aimux::core::Response response = it->second->send_request(test_request);
        auto end_time = std::chrono::steady_clock::now();

        double response_time = std::chrono::duration<double, std::milli>(end_time - start_time).count();

        // Update metrics
        update_provider_metrics(provider_name, response_time, response.success);

        nlohmann::json result;
        result["provider"] = provider_name;
        result["success"] = response.success;
        result["response_time_ms"] = response_time;
        result["response_data"] = response.data;
        result["error_message"] = response.error_message;
        result["status_code"] = response.status_code;
        result["actual_response_time_ms"] = response.response_time_ms;
        result["provider_used"] = response.provider_name;

        return HttpResponse(200, "application/json", result.dump(4));

    } catch (const nlohmann::json::parse_error& e) {
        return HttpResponse(400, "application/json",
            nlohmann::json{{"error", "Invalid JSON"}, {"message", e.what()}}.dump());
    } catch (const std::exception& e) {
        return HttpResponse(500, "application/json",
            nlohmann::json{{"error", "Test failed"}, {"message", e.what()}}.dump());
    }
}

HttpResponse WebServer::handle_api_info() {
    nlohmann::json api_info;
    api_info["title"] = "Aimux WebUI API";
    api_info["version"] = "v2.0";
    api_info["description"] = "REST API for managing Aimux AI providers and monitoring system";

    nlohmann::json endpoints = nlohmann::json::array();

    // GET endpoints
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/"},
        {"description", "Main dashboard HTML"}
    });
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/health"},
        {"description", "System health check"}
    });
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/metrics"},
        {"description", "System metrics"}
    });
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/providers"},
        {"description", "List all providers"}
    });
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/providers/{name}"},
        {"description", "Get specific provider info"}
    });
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/status"},
        {"description", "Full system status"}
    });
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/config"},
        {"description", "Get default configuration"}
    });
    endpoints.push_back({
        {"method", "GET"},
        {"path", "/api-endpoints"},
        {"description", "This API information"}
    });

    // POST endpoints
    endpoints.push_back({
        {"method", "POST"},
        {"path", "/providers"},
        {"description", "Create new provider"}
    });
    endpoints.push_back({
        {"method", "PUT"},
        {"path", "/providers/{name}"},
        {"description", "Update provider configuration"}
    });
    endpoints.push_back({
        {"method", "DELETE"},
        {"path", "/providers/{name}"},
        {"description", "Delete provider"}
    });
    endpoints.push_back({
        {"method", "POST"},
        {"path", "/test"},
        {"description", "Test a provider with a message"}
    });
    endpoints.push_back({
        {"method", "POST"},
        {"path", "/config"},
        {"description", "Update system configuration"}
    });

    api_info["endpoints"] = endpoints;

    return HttpResponse(200, "application/json", api_info.dump(4));
}

WebServer::NetworkInfo WebServer::get_network_info() const {
    NetworkInfo info;
    info.bind_address = bind_address_;
    info.resolved_bind_address = resolved_bind_address_;
    info.port = port_;

    // Get ZeroTier IP and available IPs from config manager
    try {
        auto& config_manager = aimux::config::ProductionConfigManager::getInstance();
        info.zerotier_ip = config_manager.detectZeroTierIP();
        info.available_ips = config_manager.getAvailableIPAddresses();
        info.zerotier_available = !info.zerotier_ip.empty();
    } catch (const std::exception& e) {
        info.zerotier_ip = "";
        info.zerotier_available = false;
    }

    return info;
}

} // namespace webui
} // namespace aimux